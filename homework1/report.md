
# 41343150

作業一

## 解題說明

本題要求實現一個用遞迴函式來計算 Ackermann 函式 A(m,n) 的值。

### 解題策略

1.當 m = 0 時，返回 n + 1，作為遞迴的結束條件之一。  
2.當 n = 0 時，返回 A(m - 1, 1)。  
3.如果否則，返回 A(m - 1, A(m, n - 1))，持續遞迴直到滿足結束條件。  


## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int ack(int m, int n) {
    if (m == 0) {
        return n + 1;
    } else if (n == 0) {
        return ack(m - 1, 1);
    } else {
        return ack(m - 1, ack(m, n - 1));
    }
}
int main() {
    int m, n;
    cout << "Enter m and n: ";
    cin >> m >> n;
  if (m < 0 || n < 0) {
        cout << "輸入錯誤：m 和 n 必須是 >= 0 的整數。" << endl;
        return 1;
}
    cout << "Ackermann(" << m << ", " << n << ") = " << ack(m, n) << endl;
    return 0;
}

```

## 效能分析

1.超出任何原始遞迴函數範圍，約為 O(A(m, n))
2.與遞迴深度成正比，約為 O(A(m, n))

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $m$, $n$ | 預期輸出       | 實際輸出       |
|----------|--------------------|----------------|----------------|
| 測試一   | $m = 0$, $n = 0$    | $1$            | $1$            |
| 測試二   | $m = 1$, $n = 1$    | $3$            | $3$            |
| 測試三   | $m = 2$, $n = 3$    | $9$            | $9$            |
| 測試四   | $m = 3$, $n = 2$    | $29$           | $29$           |
| 測試五   | $m = -1$, $n = 2$   | 輸入錯誤提示   | 輸入錯誤提示   |


### 編譯與執行指令

```shell
$ g++ -std=c++17 -o ackermann ackermann.cpp
$ ./ackermann
```

### 結論

1. 程式能正確遞迴計算 Ackermann 函數 $A(m, n)$ 的值，符合定義邏輯。  
2. 在 $m < 0$ 或 $n < 0$ 的情況下，程式會輸出錯誤提示，避免非定義輸入。  
3. 測試案例涵蓋了邊界與錯誤輸入情境（如 $m = 0$、$n = 0$、$m = 3, n = 2$、$m = -1$），驗證遞迴正確性與輸入防護機制。

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算 Ackermann 函數 的主要原因如下：

1. **程式邏輯簡單直觀**  
遞迴能夠以簡短的程式碼表達複雜的運算過程。
透過將問題分解成結構相同的子問題，程式邏輯更貼近數學公式的思考方式，
使程式更容易理解與維護。
2. **易於理解與實現**
遞迴的程式碼更接近 Ackermann 函數的數學表示方式，特別適合學習遞迴的基本概念。
以本程式為例：
```cpp
int ack(int m, int n) {
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return ack(m - 1, 1);
    return ack(m - 1, ack(m, n - 1));
}
```
3. **方便處理重複結構的問題**
Ackermann 函數具有深層嵌套的遞迴結構，使用遞迴可以自然地描述「整體由部分構成」的計算過程，
不需要額外的迴圈或變數來追蹤中間結果。

透過遞迴實作 Ackermann 函數，程式能夠直接對應數學定義，每一層遞迴呼叫代表一個子問題，最終逐層回傳得到完整結果。
這種設計清楚展現了遞迴思維與函式堆疊的運作方式。
