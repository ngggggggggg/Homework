# 41343150

## 作業一 Ackermann 函數

### 解題說明
本題要求實現一個用遞迴函式來計算 Ackermann 函式 A(m,n) 的值。

### 解題策略
當 m = 0 時，返回 n + 1，作為遞迴的結束條件之一。  
當 n = 0 時，返回 A(m - 1, 1)。  
否則，返回 A(m - 1, A(m, n - 1))，持續遞迴直到滿足結束條件。  

### 程式實作
```cpp
#include <iostream>
using namespace std;

int ack(int m, int n) {
    if (m == 0) {
        return n + 1;
    } else if (n == 0) {
        return ack(m - 1, 1);
    } else {
        return ack(m - 1, ack(m, n - 1));
    }
}

int main() {
    int m, n;
    cout << "Enter m and n: ";
    cin >> m >> n;
    if (m < 0 || n < 0) {
        cout << "輸入錯誤：m 和 n 必須是 >= 0 的整數。" << endl;
        return 1;
    }
    cout << "Ackermann(" << m << ", " << n << ") = " << ack(m, n) << endl;
    return 0;
}
````

### 效能分析

超出任何原始遞迴函數範圍，約為 O(A(m, n))，遞迴深度與運算量成正比。

### 測試與驗證

| 測試案例 | 輸入參數 m, n | 預期輸出   | 實際輸出   |
| ---- | --------- | ------ | ------ |
| 測試一  | 0, 0      | 1      | 1      |
| 測試二  | 1, 1      | 3      | 3      |
| 測試三  | 2, 3      | 9      | 9      |
| 測試四  | 3, 2      | 29     | 29     |
| 測試五  | -1, 2     | 輸入錯誤提示 | 輸入錯誤提示 |

### 編譯與執行指令

```shell
g++ -std=c++17 -o ackermann ackermann.cpp
./ackermann
```

### 結論

程式能正確遞迴計算 Ackermann 函數 A(m, n) 的值，並能處理 m < 0 或 n < 0 的錯誤輸入。測試案例涵蓋邊界與非定義情境，驗證遞迴正確性與輸入防護。

### 申論及開發報告

程式使用遞迴實作 Ackermann 函數，程式碼簡單直觀，易於理解，能自然處理函數深層嵌套的結構。每一層遞迴呼叫對應子問題，最終逐層回傳得到完整結果，清楚展現遞迴思維與函式堆疊運作原理。

---

## 作業二 Powerset

### 解題說明

本題要求實現一個用遞迴函式來計算集合 S 的 powerset（所有子集合）。

### 解題策略

每個元素有兩種選擇：選入子集合或不選入子集合。
使用遞迴對剩餘元素重複同樣操作，直到處理完整個集合。
當所有元素都處理完後，輸出目前子集合，形成 powerset 的一個子集合。
程式可處理任意數量的元素。

### 程式實作

```cpp
#include <iostream>
using namespace std;

void ps(int S[], int n, int sub[], int sz, int id) {
    if (id == n) {
        cout << "{";
        for (int i = 0; i < sz; ++i) {
            cout << sub[i];
            if (i != sz - 1) cout << ",";
        }
        cout << "}" << endl;
        return;
    }
    ps(S, n, sub, sz, id + 1); // 不選當前元素
    sub[sz] = S[id];
    ps(S, n, sub, sz + 1, id + 1); // 選當前元素
}

int main() {
    int S[] = {1, 2, 3};
    int n = 3;
    int sub[3];
    ps(S, n, sub, 0, 0);
    return 0;
}
```

### 效能分析

時間複雜度：O(2^n)，每個元素有選或不選兩種可能，共有 2^n 個子集合。
空間複雜度：O(n)，遞迴堆疊最大深度為 n，subset 陣列大小為 n。

### 測試與驗證

| 測試案例 | 輸入集合       | 預期輸出                                                                                                     | 實際輸出             |
| ---- | ---------- | -------------------------------------------------------------------------------------------------------- | ---------------- |
| 測試一  | {}         | {}                                                                                                       | {}               |
| 測試二  | {5}        | {},{5}                                                                                                   | {},{5}           |
| 測試三  | {1,2}      | {},{2},{1},{1,2}                                                                                         | {},{2},{1},{1,2} |
| 測試四  | {1,2,3}    | {},{3},{2},{2,3},{1},{1,3},{1,2},{1,2,3}                                                                 | 同上               |
| 測試五  | {4,7,9,10} | {},{10},{9},{9,10},{7},{7,10},{7,9},{7,9,10},{4},{4,10},{4,9},{4,9,10},{4,7},{4,7,10},{4,7,9},{4,7,9,10} | 同上               |

### 編譯與執行指令

```shell
g++ -std=c++17 -o powerset powerset.cpp
./powerset
```

### 結論

程式能正確生成集合的所有子集合，符合 powerset 定義。遞迴方式自然處理每個元素的選與不選情況，程式邏輯簡單易懂，支援任意大小集合。測試案例涵蓋空集合、單元素、多元素及較大集合，驗證正確性。

### 申論及開發報告

遞迴方式讓程式簡潔易讀，每一層遞迴代表一個元素的決策，最終組合成完整的所有子集合。遞迴呼叫自然對應 powerset 的數學結構，展示遞迴呼叫與堆疊運作原理。
