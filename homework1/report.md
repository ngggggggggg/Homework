
# 41343150

作業一

## 解題說明

本題要求實現一個用遞迴函式來計算 Ackermann 函式 A(m,n) 的值。

### 解題策略

1.當 m = 0 時，返回 n + 1，作為遞迴的結束條件之一。  
2.當 n = 0 時，返回 A(m - 1, 1)。  
3.如果否則，返回 A(m - 1, A(m, n - 1))，持續遞迴直到滿足結束條件。  


## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int ack(int m, int n) {
    if (m == 0) {
        return n + 1;
    } else if (n == 0) {
        return ack(m - 1, 1);
    } else {
        return ack(m - 1, ack(m, n - 1));
    }
}
int main() {
    int m, n;
    cout << "Enter m and n: ";
    cin >> m >> n;
  if (m < 0 || n < 0) {
        cout << "輸入錯誤：m 和 n 必須是 >= 0 的整數。" << endl;
        return 1;
}
    cout << "Ackermann(" << m << ", " << n << ") = " << ack(m, n) << endl;
    return 0;
}

```

## 效能分析

1.超出任何原始遞迴函數範圍，約為 O(A(m, n))
2.與遞迴深度成正比，約為 O(A(m, n))

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $m$, $n$ | 預期輸出       | 實際輸出       |
|----------|--------------------|----------------|----------------|
| 測試一   | $m = 0$, $n = 0$    | $1$            | $1$            |
| 測試二   | $m = 1$, $n = 1$    | $3$            | $3$            |
| 測試三   | $m = 2$, $n = 3$    | $9$            | $9$            |
| 測試四   | $m = 3$, $n = 2$    | $29$           | $29$           |
| 測試五   | $m = -1$, $n = 2$   | 輸入錯誤提示   | 輸入錯誤提示   |


### 編譯與執行指令

```shell
$ g++ -std=c++17 -o ackermann ackermann.cpp
$ ./ackermann
```

### 結論

1. 程式能正確遞迴計算 Ackermann 函數 $A(m, n)$ 的值，符合定義邏輯。  
2. 在 $m < 0$ 或 $n < 0$ 的情況下，程式會輸出錯誤提示，避免非定義輸入。  
3. 測試案例涵蓋了邊界與錯誤輸入情境（如 $m = 0$、$n = 0$、$m = 3, n = 2$、$m = -1$），驗證遞迴正確性與輸入防護機制。

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算 Ackermann 函數 的主要原因如下：

1. **程式邏輯簡單直觀**  
遞迴能夠以簡短的程式碼表達複雜的運算過程。
透過將問題分解成結構相同的子問題，程式邏輯更貼近數學公式的思考方式，
使程式更容易理解與維護。
2. **易於理解與實現**
遞迴的程式碼更接近 Ackermann 函數的數學表示方式，特別適合學習遞迴的基本概念。
以本程式為例：
```cpp
int ack(int m, int n) {
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return ack(m - 1, 1);
    return ack(m - 1, ack(m, n - 1));
}
```
3. **方便處理重複結構的問題**
Ackermann 函數具有深層嵌套的遞迴結構，使用遞迴可以自然地描述「整體由部分構成」的計算過程，
不需要額外的迴圈或變數來追蹤中間結果。

透過遞迴實作 Ackermann 函數，程式能夠直接對應數學定義，每一層遞迴呼叫代表一個子問題，最終逐層回傳得到完整結果。
這種設計清楚展現了遞迴思維與函式堆疊的運作方式。



作業二

## 解題說明
本題要求實現一個用遞迴函式來計算集合 S 的 powerset（所有的子集合）。
### 解題策略
1. 每個元素有兩種選擇：**選入子集合**或**不選入子集合**。  
2. 使用遞迴對剩餘元素重複同樣操作，直到處理完整個集合。  
3. 當所有元素都處理完後，輸出目前子集合，形成 powerset 的一個子集合。    
4. 不限制集合大小，程式可處理任意數量的元素。  

## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

void ps(int S[], int n, int sub[], int sz, int id) {
    if (id == n) {
        cout << "{";
        for (int i = 0; i < sz; ++i) {
            cout << sub[i];
            if (i != sz - 1) cout << ",";
        }
        cout << "}" << endl;
        return;
    }
    ps(S, n, sub, sz, id + 1);
    sub[sz] = S[id];
    ps(S, n, sub, sz + 1, id + 1);
}

int main() {
    int S[] = {1, 2, 3};
    int n = 3;
    int sub[3];
    ps(S, n, sub, 0, 0);
    return 0;
}
```

## 效能分析

1.時間複雜度：O(2^n)，因為每個元素有選或不選兩種可能，共有 2^n 個子集合。  
2.空間複雜度：O(n)，遞迴堆疊最大深度為 n，subset 陣列大小為 n。  

## 測試與驗證

### 測試案例

| 測試案例 | 輸入集合 | 預期輸出 | 實際輸出 |
|----------|----------|----------|----------|
| 測試一   | {}       | {}       | {}       |
| 測試二   | {5}      | {},{5}  | {},{5}  |
| 測試三   | {1,2}    | {},{2},{1},{1,2} | {},{2},{1},{1,2} |
| 測試四   | {1,2,3}  | {},{3},{2},{2,3},{1},{1,3},{1,2},{1,2,3} | {},{3},{2},{2,3},{1},{1,3},{1,2},{1,2,3} |
| 測試五   | {4,7,9,10} | {},{10},{9},{9,10},{7},{7,10},{7,9},{7,9,10},{4},{4,10},{4,9},{4,9,10},{4,7},{4,7,10},{4,7,9},{4,7,9,10} | 同上 |


### 編譯與執行指令

```shell
$ g++ -std=c++17 -o powerset powerset.cpp
$ ./powerset
```

### 結論
1.程式能正確生成集合的所有子集合，符合 powerset 定義。  
2.遞迴方式自然處理每個元素的「選或不選」情況，邏輯簡單易懂。  
3.程式支援任意大小的集合，測試案例涵蓋空集合、單元素、多元素及較大集合，驗證正確性。  

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算 Ackermann 函數 的主要原因如下：

1. **程式邏輯簡單直觀**  
每個元素都有「選」或「不選」兩種可能，遞迴能自然地將這兩種情況拆開處理。  
相比迴圈方式，遞迴更貼近問題本質，程式碼簡短而清楚。
2. **對應數學定義**
owerset 的數學定義就是所有子集合的集合，遞迴呼叫正好對應「生成子集合的每一個分支」。  
   程式核心片段如下：
```cpp
ps(S, n, sub, sz, id + 1); // 不選當前元素
sub[sz] = S[id];
ps(S, n, sub, sz + 1, id + 1); // 選當前元素
```
3. **適合處理重複結構**
每個元素的處理邏輯相同（選或不選），遞迴能自然地重複應用這個邏輯，無需額外變數或巢狀迴圈追蹤狀態。

遞迴方式不僅讓程式簡潔易讀，也與 powerset 的數學結構一致，每一層遞迴代表一個元素的決策，最終組合成完整的所有子集合。
此種設計同時展示了遞迴呼叫與堆疊運作的原理。
