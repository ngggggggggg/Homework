
# 41343150

作業二

## 解題說明
本題要求實現一個用遞迴函式來計算集合 S 的 powerset（所有的子集合）。
### 解題策略
1. 每個元素有兩種選擇：**選入子集合**或**不選入子集合**。  
2. 使用遞迴對剩餘元素重複同樣操作，直到處理完整個集合。  
3. 當所有元素都處理完後，輸出目前子集合，形成 powerset 的一個子集合。  
4. 不限制集合大小，程式可處理任意數量的元素。

## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

void ps(int S[], int n, int sub[], int sz, int id) {
    if (id == n) {
        cout << "{";
        for (int i = 0; i < sz; ++i) {
            cout << sub[i];
            if (i != sz - 1) cout << ",";
        }
        cout << "}" << endl;
        return;
    }
    ps(S, n, sub, sz, id + 1);
    sub[sz] = S[id];
    ps(S, n, sub, sz + 1, id + 1);
}

int main() {
    int S[] = {1, 2, 3};
    int n = 3;
    int sub[3];
    ps(S, n, sub, 0, 0);
    return 0;
}
```

## 效能分析

1.時間複雜度：O(2^n)，因為每個元素有選或不選兩種可能，共有 2^n 個子集合。
2.空間複雜度：O(n)，遞迴堆疊最大深度為 n，subset 陣列大小為 n。

## 測試與驗證

### 測試案例

| 測試案例 | 輸入集合 | 預期輸出 | 實際輸出 |
|----------|----------|----------|----------|
| 測試一   | {}       | {}       | {}       |
| 測試二   | {5}      | {},{5}  | {},{5}  |
| 測試三   | {1,2}    | {},{2},{1},{1,2} | {},{2},{1},{1,2} |
| 測試四   | {1,2,3}  | {},{3},{2},{2,3},{1},{1,3},{1,2},{1,2,3} | {},{3},{2},{2,3},{1},{1,3},{1,2},{1,2,3} |
| 測試五   | {4,7,9,10} | {},{10},{9},{9,10},{7},{7,10},{7,9},{7,9,10},{4},{4,10},{4,9},{4,9,10},{4,7},{4,7,10},{4,7,9},{4,7,9,10} | 同上 |


### 編譯與執行指令

```shell
$ g++ -std=c++17 -o ackermann ackermann.cpp
$ ./ackermann
```

### 結論

1. 程式能正確遞迴計算 Ackermann 函數 $A(m, n)$ 的值，符合定義邏輯。  
2. 在 $m < 0$ 或 $n < 0$ 的情況下，程式會輸出錯誤提示，避免非定義輸入。  
3. 測試案例涵蓋了邊界與錯誤輸入情境（如 $m = 0$、$n = 0$、$m = 3, n = 2$、$m = -1$），驗證遞迴正確性與輸入防護機制。

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算 Ackermann 函數 的主要原因如下：

1. **程式邏輯簡單直觀**  
遞迴能夠以簡短的程式碼表達複雜的運算過程。
透過將問題分解成結構相同的子問題，程式邏輯更貼近數學公式的思考方式，
使程式更容易理解與維護。
2. **易於理解與實現**
遞迴的程式碼更接近 Ackermann 函數的數學表示方式，特別適合學習遞迴的基本概念。
以本程式為例：
```cpp
int ack(int m, int n) {
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return ack(m - 1, 1);
    return ack(m - 1, ack(m, n - 1));
}
```
3. **方便處理重複結構的問題**
Ackermann 函數具有深層嵌套的遞迴結構，使用遞迴可以自然地描述「整體由部分構成」的計算過程，
不需要額外的迴圈或變數來追蹤中間結果。

透過遞迴實作 Ackermann 函數，程式能夠直接對應數學定義，每一層遞迴呼叫代表一個子問題，最終逐層回傳得到完整結果。
這種設計清楚展現了遞迴思維與函式堆疊的運作方式。
