
# 41343150

作業二

## 解題說明
本題要求實現一個用遞迴函式來計算集合 S 的 powerset（所有的子集合）。
### 解題策略
1. 每個元素有兩種選擇：**選入子集合**或**不選入子集合**。  
2. 使用遞迴對剩餘元素重複同樣操作，直到處理完整個集合。  
3. 當所有元素都處理完後，輸出目前子集合，形成 powerset 的一個子集合。    
4. 不限制集合大小，程式可處理任意數量的元素。  

## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

void ps(int S[], int n, int sub[], int sz, int id) {
    if (id == n) {
        cout << "{";
        for (int i = 0; i < sz; ++i) {
            cout << sub[i];
            if (i != sz - 1) cout << ",";
        }
        cout << "}" << endl;
        return;
    }
    ps(S, n, sub, sz, id + 1);
    sub[sz] = S[id];
    ps(S, n, sub, sz + 1, id + 1);
}

int main() {
    int S[] = {1, 2, 3};
    int n = 3;
    int sub[3];
    ps(S, n, sub, 0, 0);
    return 0;
}
```

## 效能分析

1.時間複雜度：O(2^n)，因為每個元素有選或不選兩種可能，共有 2^n 個子集合。  
2.空間複雜度：O(n)，遞迴堆疊最大深度為 n，subset 陣列大小為 n。  

## 測試與驗證

### 測試案例

| 測試案例 | 輸入集合 | 預期輸出 | 實際輸出 |
|----------|----------|----------|----------|
| 測試一   | {}       | {}       | {}       |
| 測試二   | {5}      | {},{5}  | {},{5}  |
| 測試三   | {1,2}    | {},{2},{1},{1,2} | {},{2},{1},{1,2} |
| 測試四   | {1,2,3}  | {},{3},{2},{2,3},{1},{1,3},{1,2},{1,2,3} | {},{3},{2},{2,3},{1},{1,3},{1,2},{1,2,3} |
| 測試五   | {4,7,9,10} | {},{10},{9},{9,10},{7},{7,10},{7,9},{7,9,10},{4},{4,10},{4,9},{4,9,10},{4,7},{4,7,10},{4,7,9},{4,7,9,10} | 同上 |


### 編譯與執行指令

```shell
$ g++ -std=c++17 -o powerset powerset.cpp
$ ./powerset
```

### 結論
1.程式能正確生成集合的所有子集合，符合 powerset 定義。  
2.遞迴方式自然處理每個元素的「選或不選」情況，邏輯簡單易懂。  
3.程式支援任意大小的集合，測試案例涵蓋空集合、單元素、多元素及較大集合，驗證正確性。  

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算 Ackermann 函數 的主要原因如下：

1. **程式邏輯簡單直觀**  
每個元素都有「選」或「不選」兩種可能，遞迴能自然地將這兩種情況拆開處理。  
相比迴圈方式，遞迴更貼近問題本質，程式碼簡短而清楚。
2. **對應數學定義**
owerset 的數學定義就是所有子集合的集合，遞迴呼叫正好對應「生成子集合的每一個分支」。  
   程式核心片段如下：
```cpp
ps(S, n, sub, sz, id + 1); // 不選當前元素
sub[sz] = S[id];
ps(S, n, sub, sz + 1, id + 1); // 選當前元素

3. **適合處理重複結構**
每個元素的處理邏輯相同（選或不選），遞迴能自然地重複應用這個邏輯，無需額外變數或巢狀迴圈追蹤狀態。

遞迴方式不僅讓程式簡潔易讀，也與 powerset 的數學結構一致，每一層遞迴代表一個元素的決策，最終組合成完整的所有子集合。
此種設計同時展示了遞迴呼叫與堆疊運作的原理。
